@using System.Collections
@using System.Drawing
@using System.Timers
@using EMQ.Shared.Core
@using EMQ.Shared.Core.UI
@using EMQ.Shared.Quiz.Entities.Concrete
@using Microsoft.AspNetCore.SignalR.Client
@inject ClientUtils _clientUtils

@* <h6>TreasureRoomComponent</h6> *@

<div id="countdownDiv" style="font-size: xxx-large; color: white;">
    @((int) Math.Round(Countdown / 1000))
</div>

<div id="treasureRoomMainDiv" tabindex="0" @ref="_treasureRoomMainDivRef"
     style="width: @(LootingConstants.TreasureRoomWidth)px; height: @(LootingConstants.TreasureRoomHeight)px;
      background-color: gray; word-wrap: break-word; position: absolute; left: 50%; transform: translate(-50%, 0);"
     @onkeydown="OnKeyDown" @onkeyup="OnKeyUp">

    @if (Room != null)
    {
        Console.WriteLine(JsonSerializer.Serialize(Room));
        var ownPlayer = Room!.Players.Single(x => x.Id == ClientState.Session!.Player.Id);
        var currentTreasureRoomCoords = Room.Players.Single(x => x.Id == ownPlayer.Id).LootingInfo.TreasureRoomCoords;
        @foreach (var player in Room.Players)
        {
            @if (player.LootingInfo.TreasureRoomCoords == currentTreasureRoomCoords)
            {
                @if (player.Id == ownPlayer.Id)
                {
                    <div id="treasureRoomInventoryDiv"
                         style="position: absolute; left: 5px; top: 10px; max-width: @(LootingConstants.TreasureRoomWidth / 3)px;
                          overflow: hidden; text-overflow: ellipsis; white-space: nowrap; ">
                        Inventory <span style="margin-left: @(LootingConstants.TreasureRoomWidth / 6)px;">@(Room.QuizSettings.InventorySize - player.LootingInfo.Inventory.Count)</span>
                        <br/>
                        @if (player.LootingInfo.Inventory.Any())
                        {
                            @foreach (var treasure in player.LootingInfo.Inventory)
                            {
                                <span style="cursor: pointer"
                                      @onclick="@(() => DropTreasure(treasure))">
                                    @* todo title selection *@
                                    @treasure.ValidSource.Value.First(x => x.IsMainTitle).LatinTitle
                                </span>
                                <br/>
                            }
                        }
                    </div>
                }

                <div class="treasureRoomPlayerDiv" style="z-index: 3000000; display: inline-block; position: absolute; left: @(player.LootingInfo.X)px; top: @(player.LootingInfo.Y)px;">
                    <img width="@(LootingConstants.PlayerAvatarSize)px" height="@(LootingConstants.PlayerAvatarSize)px"
                         src="@Avatar.GetUrlByPlayerState(player.Avatar, PlayerStatus.Looting)" alt="Avatar"
                         style="border-radius: 50%;">
                </div>
            }
        }

        @if (Room.TreasureRooms[currentTreasureRoomCoords.X][currentTreasureRoomCoords.Y].Treasures.Any())
        {
            @foreach (var treasure in Room.TreasureRooms[currentTreasureRoomCoords.X][currentTreasureRoomCoords.Y].Treasures)
            {
                <div class="treasure"
                     style="word-wrap: break-word; position: absolute; left: @(treasure.Position.X)px; top: @(treasure.Position.Y)px; cursor: pointer;
                  color: @UiHelpers.Bool2Color(treasure.Position.IsReachableFromCoords((int) ownPlayer.LootingInfo.X, (int) ownPlayer.LootingInfo.Y), "green", "red");"
                     @onclick="@(() => PickupTreasure(treasure))">
                    @* todo title selection *@
                    @treasure.ValidSource.Value.First(x => x.IsMainTitle).LatinTitle
                </div>
            }
        }

        @foreach ((Direction direction, Point treasureRoomCoords) in Room.TreasureRooms[currentTreasureRoomCoords.X][currentTreasureRoomCoords.Y].Exits)
        {
            Point arrowPosition;
            string arrowText;
            switch (direction)
            {
                case Direction.North:
                    arrowPosition = new Point(LootingConstants.TreasureRoomWidth / 2, 0);
                    arrowText = "↑";
                    break;
                case Direction.East:
                    arrowPosition = new Point(LootingConstants.TreasureRoomWidth - 40, LootingConstants.TreasureRoomHeight / 2);
                    arrowText = "→";
                    break;
                case Direction.South:
                    arrowPosition = new Point(LootingConstants.TreasureRoomWidth / 2, LootingConstants.TreasureRoomHeight - 50);
                    arrowText = "↓";
                    break;
                case Direction.West:
                    arrowPosition = new Point(5, LootingConstants.TreasureRoomHeight / 2);
                    arrowText = "←";
                    break;
                // case Direction.Northeast:
                //     break;
                // case Direction.Northwest:
                //     break;
                // case Direction.Southeast:
                //     break;
                // case Direction.Southwest:
                //     break;
                default:
                    throw new ArgumentOutOfRangeException();
            }

            <div class="changeTreasureRoomArrowDiv"
                 style="position: absolute; left: @(arrowPosition.X)px; top:@(arrowPosition.Y)px;
                          font-size: xx-large; cursor: pointer;
                          color: @UiHelpers.Bool2Color(arrowPosition.IsReachableFromCoords((int) ownPlayer.LootingInfo.X, (int) ownPlayer.LootingInfo.Y), "green", "red");
                          pointer-events: @UiHelpers.Bool2PointerEvents(arrowPosition.IsReachableFromCoords((int) ownPlayer.LootingInfo.X, (int) ownPlayer.LootingInfo.Y));"
                 @onclick="@(() => OnclickChangeTreasureRoomArrow(arrowPosition, treasureRoomCoords))">
                @arrowText
            </div>
        }
    }

</div>

@code {

    // apparently these properties are null on the first render, before they are initialized through the Parameter attribute (???)

    [Parameter]
    public Room? Room { get; set; }

    [Parameter]
    public float Countdown { get; set; }

    private ElementReference _treasureRoomMainDivRef;

    private Timer _movementTimer = new() { Interval = 17 };

    private Dictionary<string, bool> Keys { get; set; } = new()
    {
        { "arrowup", false },
        { "arrowdown", false },
        { "arrowleft", false },
        { "arrowright", false },
        { "w", false },
        { "s", false },
        { "a", false },
        { "d", false },
    };

    protected override async Task OnInitializedAsync()
    {
        _movementTimer.Elapsed += MovementTimerOnElapsed;
        _movementTimer.Start();
    }

    private void MovementTimerOnElapsed(object? sender, ElapsedEventArgs e)
    {
    // todo? fix diagonal movement being faster
        const float speed = 4f; // todo make this a quiz setting?

        var player = Room!.Players.Single(x => x.Id == ClientState.Session!.Player.Id);
        var newX = player.LootingInfo.X;
        var newY = player.LootingInfo.Y;

        var moved = false;

        if (Keys["arrowup"] || Keys["w"])
        {
            newY -= speed;
            moved = true;
        }

        if (Keys["arrowdown"] || Keys["s"])
        {
            newY += speed;
            moved = true;
        }

        if (Keys["arrowleft"] || Keys["a"])
        {
            newX -= speed;
            moved = true;
        }

        if (Keys["arrowright"] || Keys["d"])
        {
            newX += speed;
            moved = true;
        }

        if (moved)
        {
    // bounds check
            if (newX > 0 && newX < LootingConstants.TreasureRoomWidth - LootingConstants.PlayerAvatarSize)
            {
                player.LootingInfo.X = newX;
            }
            if (newY > 0 && newY < LootingConstants.TreasureRoomHeight - LootingConstants.PlayerAvatarSize)
            {
                player.LootingInfo.Y = newY;
            }

            StateHasChanged();

    // can't afford to wait for this call
#pragma warning disable CS4014
            ReportPositionToServer(newX, newY);
#pragma warning restore CS4014
        }
    }

    private async Task ReportPositionToServer(float newX, float newY)
    {
        await ClientState.Session!.hubConnection!.SendAsync("SendPlayerMoved", newX, newY, DateTime.UtcNow);
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            await _treasureRoomMainDivRef.FocusAsync();
        }
    }

    private async Task PickupTreasure(Treasure treasure)
    {
        var player = Room!.Players.Single(x => x.Id == ClientState.Session!.Player.Id);
        if (treasure.Position.IsReachableFromCoords((int) player.LootingInfo.X, (int) player.LootingInfo.Y))
        {
            await ClientState.Session!.hubConnection!.SendAsync("SendPickupTreasure", treasure.Guid);
        }
    }

    private async Task DropTreasure(Treasure treasure)
    {
        await ClientState.Session!.hubConnection!.SendAsync("SendDropTreasure", treasure.Guid);
    }

    private void OnKeyDown(KeyboardEventArgs e)
    {
    // Console.WriteLine(e.Key);
        if (Keys.ContainsKey(e.Key.ToLowerInvariant()))
        {
            Keys[e.Key.ToLowerInvariant()] = true;
        }
    }

    private void OnKeyUp(KeyboardEventArgs e)
    {
    // Console.WriteLine(e.Key);
        if (Keys.ContainsKey(e.Key.ToLowerInvariant()))
        {
            Keys[e.Key.ToLowerInvariant()] = false;
        }
    }

    private async Task OnclickChangeTreasureRoomArrow(Point arrowPosition, Point treasureRoomCoords)
    {
        var player = Room!.Players.Single(x => x.Id == ClientState.Session!.Player.Id);
        if (arrowPosition.IsReachableFromCoords((int) player.LootingInfo.X, (int) player.LootingInfo.Y))
        {
            await ClientState.Session!.hubConnection!.SendAsync("SendChangeTreasureRoom", treasureRoomCoords);
        }
    }

    public void CallStateHasChanged(Room room)
    {
        Room = room;
        StateHasChanged();
    }

}
