@using EMQ.Shared.Auth.Entities.Concrete.Dto.Response
@using EMQ.Shared.Quiz.Entities.Concrete
@using Microsoft.AspNetCore.Components.QuickGrid
@using EMQ.Client.Pages
@using EMQ.Shared.Auth.Entities.Concrete
@using EMQ.Shared.Core
@using EMQ.Shared.Core.SharedDbEntities
@inject HttpClient _client
@inject NavigationManager _navigation
@inject ClientUtils _clientUtils

<ReviewEditComponent @ref="_reviewEditComponent" CurrentEQs="@(CurrentEQs)" ParentStateHasChangedCallback="@CallStateHasChanged"/>

<button type="button" class="btn btn-primary" @onclick="@(() => _navigation.NavigateTo($"{_navigation.BaseUri}ea{ArtistId - 1}"))">Prev</button>
<button type="button" class="btn btn-primary" @onclick="@(() => _navigation.NavigateTo($"{_navigation.BaseUri}ea{ArtistId + 1}"))">Next</button>
<br/>

@if (ResGetSongArtist != null)
{
    var artist = ResGetSongArtist.SongArtists.First();
    <ArtistInfoCardComponent Artist="@artist"></ArtistInfoCardComponent>
    @if (ClientUtils.HasEditPerms())
    {
        <details>
            <summary>Edit artist</summary>
            <EditArtistComponent Artist="artist" IsNew="false"></EditArtistComponent>
        </details>

        <details>
            <summary>Merge artist</summary>
            <input id="InputMergeArtist" type="text" style="width: 300px;" @bind=@InputMergeArtistText/>
            <label for="InputMergeArtist">EMQ artist id or URL</label>
            <br/>
            <br/>
            <button type="button" class="btn btn-primary" @onclick="OnClick_ButtonCreateMergeEdit" disabled="@(string.IsNullOrWhiteSpace(InputMergeArtistText))">
                Create merge edit
            </button>
        </details>
    }
}

<span style="cursor: pointer;" title="History"
      @onclick="@(async () => CurrentEQs = await ClientUtils.OnclickEntityHistory(EntityKind.SongArtist, ArtistId, _client, _reviewEditComponent))">
    ⟲
</span>
<br/>

@if (PlayerSongStats != null)
{
    <h5>Stats</h5>
    <div class="page-size-chooser">
        Items per page:
        <select @bind="@_paginationPlayerSongStats.ItemsPerPage">
            <option>10</option>
            <option>25</option>
            <option>50</option>
            <option>100</option>
            <option>250</option>
        </select>
    </div>
    <div>
        <Paginator State="@_paginationPlayerSongStats"/>
    </div>
    <div class="grid" tabindex="-1">
        <QuickGrid Items="@PlayerSongStats" Pagination="@_paginationPlayerSongStats">
            <PropertyColumn Property="@(x => x.Username)" Title="Username" Sortable="true"/>
            <PropertyColumn Property="@(x => x.TimesPlayed)" Title="Play count" Sortable="true" IsDefaultSortColumn="true" InitialSortDirection="SortDirection.Descending"/>
            <TemplateColumn Title="Guess rate" Sortable="true" SortBy="@(GridSort<PlayerSongStats>.ByAscending(x => x.CorrectPercentage))">
                @(Math.Round((double)context.CorrectPercentage, 2))%
            </TemplateColumn>
            <PropertyColumn Property="@(x => x.VoteAverage)" Title="Vote avg." Sortable="true"/>
            <PropertyColumn Property="@(x => x.VoteCount)" Title="Vote count" Sortable="true"/>
        </QuickGrid>
    </div>
    <br/>
}

@code {

    [Parameter]
    public int ArtistId { get; set; }

    private ResGetSongArtist? ResGetSongArtist { get; set; }

    private IQueryable<PlayerSongStats>? PlayerSongStats { get; set; }

    private readonly PaginationState _paginationPlayerSongStats = new() { ItemsPerPage = 10 };

    public string? InputMergeArtistText { get; set; }

    private IQueryable<EditQueue>? CurrentEQs { get; set; }

    public ReviewEditComponent _reviewEditComponent { get; set; } = null!;

    protected override async Task OnParametersSetAsync()
    {
        await _clientUtils.TryRestoreSession(); // needs to be here instead of the page otherwise it runs too late
    // PlayerSongStats = null;
    // StateHasChanged(); // fetched fast enough to make the flickering not worth it

        HttpResponseMessage res1 = await _client.PostAsJsonAsync("Library/GetSongArtistWithStats", new SongArtist { Id = ArtistId });
        if (res1.IsSuccessStatusCode)
        {
            var content = (await res1.Content.ReadFromJsonAsync<ResGetSongArtist>())!;
            if (!content.SongArtists.Any())
            {
                return;
            }

            ResGetSongArtist = content;
            PlayerSongStats = content.PlayerSongStats.AsQueryable();
    // StateHasChanged();
        }
    }

    private async Task OnClick_ButtonCreateMergeEdit()
    {
        if (!int.TryParse(InputMergeArtistText?
            .Replace("https://", "")
            .Replace($"{Constants.WebsiteDomainNoProtocol}", "")
            .Replace("/", "")
            .Replace("ea", ""),
            out int aid) || aid <= 0 || aid == ArtistId)
        {
            InputMergeArtistText = "Invalid input.";
            return;
        }

        var req = new MergeArtists
        {
            Id = ArtistId,
            SourceId = aid,
            SourceName = Converters.GetSingleTitle(ResGetSongArtist!.SongArtists.First().Titles).ToString(),
        };

        HttpResponseMessage res = await _client.PostAsJsonAsync("Library/EditMergeArtists", req);
        InputMergeArtistText = res.IsSuccessStatusCode ? "Added to the edit queue." : "Failed.";
    }

    private async Task CallStateHasChanged()
    {
        StateHasChanged();
    }

}
